' MikroBasic

const PWM_RESOLUTION                                  = 4096
const PWM_PRE_SCALE                                   = 0xFE
const PWM_MODE1                                       = 0x00
const PWM_MODE2                                       = 0x01
const PWM_CHANNEL                                     = 0x06
const PWM_ALL                                         = 0xFA
const M1_ALLCALL                                          = 0
const M1_SUB3                                             = 1
const M1_SUB2                                             = 2
const M1_SUB1                                             = 3
const M1_SLEEP                                            = 4
const M1_AI                                               = 5
const M1_EXTCLK                                           = 6
const M1_RESTART                                          = 7
const M2_OUTNE                                            = 0
const M2_OUTDRV                                           = 2
const M2_OCH                                              = 3
const M2_INVERT                                           = 4

dim tmp_cmd as char
dim tmp_data as char[ 4 ]

sub procedure pwm_init( char i2c_dev_addr )
sub procedure pwm_device_config( char allcall, char sub3, char sub2, char sub1, char sleep, char restart )

' and so on
' ...

sud procedure pwm_init( char i2c_dev_addr )
{
    

    pwm_device_config( 1, 0, 0, 1, 1, 0 );
    pwm_set_pre_scale( 4 );
    pwm_device_config( 1, 0, 0, 0, 0, 1 );
    pwm_output_config( 0, 1, 0, 0 );
}

sud procedure pwm_device_config( char allcall, char sub3, char sub2, char sub1, char sleep, char restart )
{
    tmp_cmd = PWM_MODE1;
    tmp_data = 32;

    tmp_data |= ( sub1 & 0x01 )     << M1_SUB1;
    tmp_data |= ( sub2 & 0x01 )     << M1_SUB2;
    tmp_data |= ( sub3 & 0x01 )     << M1_SUB3;
    tmp_data |= ( sleep & 0x01 )    << M1_SLEEP;
    tmp_data |= ( allcall & 0x01 )  << M1_ALLCALL;
    tmp_data |= ( restart & 0x01 )  << M1_RESTART;

    //pwm_hal_write( &tmp_cmd, &tmp_data, 1 );

    /* I2C write
        i2c address 1
	tmp buffer  1 byte
	tmp_data    1 byte
    */

    Delay_ms( 10 );
}



void pwm_output_config( uint8_t state,
                        bool out,
                        bool och,
                        bool invert )
{
    uint8_t tmp_cmd = PWM_MODE2;
    uint8_t tmp_data = 0x00;

    if( state > 3 )
        return;

    tmp_data |= ( state & 0x03 )    << M2_OUTNE;
    tmp_data |= ( out & 0x01 )      << M2_OUTDRV;
    tmp_data |= ( och & 0x01 )      << M2_OCH;
    tmp_data |= ( invert & 0x01 )   << M2_INVERT;

    //pwm_hal_write( &tmp_cmd, &tmp_data, 1 );
    
    /* I2C write
	tmp buffer 1 byte
	tmp_data   1 byte
    */
    Delay_ms( 10 );
}

void pwm_set_pre_scale( uint8_t pre_scale )
{
    uint8_t tmp_cmd = PWM_PRE_SCALE;
    uint8_t tmp_data = pre_scale;

    if( pre_scale < 0x03 )
        return;

    //pwm_hal_write( &tmp_cmd, &tmp_data, 1 );

    /* I2C write 
	tmp buffer 1 byte
	tmp_data   1 byte
    */
    Delay_ms( 10 );
}

void pwm_set_channel_raw( uint8_t channel_id,
                          uint16_t raw_offset,
                          uint16_t raw_dc )
{
    uint8_t tmp_cmd = 0;
    uint8_t tmp_data[ 4 ] = { 0 };
    uint16_t tmp_off = 0;

    if( channel_id >15 || raw_offset >PWM_RESOLUTION || raw_dc >PWM_RESOLUTION )
        return;

    tmp_cmd = channel_id * 4 + PWM_CHANNEL;
    tmp_off = ( raw_offset + raw_dc ) % PWM_RESOLUTION;

    tmp_data[ 0 ] = raw_offset & 0x00FF;
    tmp_data[ 1 ] = ( raw_offset & 0x0F00 ) >> 8;
    tmp_data[ 2 ] = tmp_off & 0x00FF;
    tmp_data[ 3 ] = ( tmp_off  & 0x0F00 ) >> 8;

    //pwm_hal_write( &tmp_cmd, &tmp_data[ 0 ], 4 );
    
    /* I2C write 
	tmp buffer 1 byte
	tmp_data   4 bytes
    */
}

void pwm_set_channel( uint8_t channel_id,
                      uint8_t offset,
                      uint8_t duty_cycle )
{
    uint16_t raw_offset = 0;
    uint16_t raw_dc = 0;

    raw_offset = PWM_RESOLUTION / 100 * offset;
    raw_dc = PWM_RESOLUTION / 100 * duty_cycle;

    pwm_set_channel_raw( channel_id, raw_offset, raw_dc );
}

void pwm_set_all_raw( uint16_t raw_dc )
{
    uint8_t tmp_cmd = PWM_ALL;
    uint8_t tmp_data[ 4 ] = { 0 };

    if( raw_dc > PWM_RESOLUTION )
        return;

    tmp_data[ 0 ] = 0x00;
    tmp_data[ 1 ] = 0x00;
    tmp_data[ 2 ] = raw_dc & 0x00FF;
    tmp_data[ 3 ] = ( raw_dc & 0x0F00 ) >> 8;

    //pwm_hal_write( &tmp_cmd, &tmp_data[ 0 ], 4 );
    
    /* I2C write 
        tmp buffer 1 byte	
	tmp_data   4 bytes
    */
	
}

void pwm_set_all( uint8_t duty_cycle )
{
    uint16_t raw_dc = 0;

    raw_dc = PWM_RESOLUTION / 100 * duty_cycle;

    pwm_set_all_raw( raw_dc );
}

void pwm_channel_state( uint8_t channel_id,
                        bool state )
{
    uint8_t tmp_cmd = 0;
    uint8_t tmp_data[ 4 ] = { 0 };

    if( channel_id > 15 )
        return;

    tmp_cmd = channel_id * 4 + PWM_CHANNEL;

    //pwm_hal_read( &tmp_cmd, &tmp_data, 4 );

    /* I2C write - 1 byte
         tmp_cmd
       I2C read
         tmp_data - 4 bytes
    */

    if( state )
    {
        tmp_data[ 1 ] |= 0x10;
        tmp_data[ 3 ] &= 0xEF;

    } else {

        tmp_data[ 1 ] &= 0xEF;
        tmp_data[ 3 ] |= 0x10;
    }

    //pwm_hal_write( &tmp_cmd, &tmp_data, 4 );
    
    /* I2C write 
        tmp buffer 1 byte	
	tmp_data   4 bytes
    */
}

void pwm_all_state( bool state )
{
    uint8_t tmp_cmd = PWM_ALL;
    uint8_t tmp_data[ 4 ] = { 0 };

    //pwm_hal_read( &tmp_cmd, &tmp_data, 4 );
    /* I2C write - 1 byte
         tmp_cmd
       I2C read
         tmp_data - 4 bytes
    */ 

    if( state )
    {
        tmp_data[ 1 ] |= 0x10;
        tmp_data[ 3 ] &= 0xEF;

    } else {

        tmp_data[ 1 ] &= 0xEF;
        tmp_data[ 3 ] |= 0x10;
    }

    //pwm_hal_write( &tmp_cmd, &tmp_data, 4 );

    /* I2C write 
        tmp buffer 1 byte	
	tmp_data   4 bytes
    */

}
/*************** END OF FUNCTIONS *********************************************/
